<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DLPerf Analysis Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-regression@2.0.0/dist/chartjs-plugin-regression.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            text-align: center;
        }

        h1 {
            color: #667eea;
            font-size: 2.4em;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #555;
            font-size: 1.05em;
        }

        .controls-panel {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.12);
            margin-bottom: 25px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 20px;
        }

        .controls-panel label {
            font-weight: 600;
            color: #444;
            margin-right: 10px;
        }

        .gpu-select {
            padding: 12px 15px;
            border-radius: 10px;
            border: 1px solid #cbd5f5;
            font-size: 1em;
            min-width: 280px;
            background: #f8f9ff;
            color: #333;
        }

        .control-note {
            color: #666;
            font-size: 0.95em;
            max-width: 520px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(210px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 22px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
        }

        .stat-value {
            font-size: 2.1em;
            font-weight: bold;
            color: #667eea;
            margin: 8px 0;
        }

        .stat-label {
            color: #666;
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .chart-container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .chart-title {
            font-size: 1.4em;
            color: #333;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #667eea;
        }

        .chart-subtitle {
            color: #555;
            font-size: 0.95em;
            margin-bottom: 15px;
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
        }

        .chart-wrapper.tall {
            height: 520px;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
            gap: 25px;
            margin-bottom: 20px;
        }

        .correlation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .correlation-table th,
        .correlation-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
        }

        .correlation-table th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }

        .correlation-table tr:hover {
            background: #f8f9fb;
        }

        .correlation-value {
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 6px;
            display: inline-block;
        }

        .correlation-high {
            background: #16a34a;
            color: white;
        }

        .correlation-medium {
            background: #f97316;
            color: white;
        }

        .correlation-low {
            background: #ef4444;
            color: white;
        }

        .placeholder {
            background: #eef2ff;
            border: 1px dashed #818cf8;
            border-radius: 12px;
            padding: 18px;
            color: #4338ca;
            text-align: center;
            margin-bottom: 15px;
        }

        .hidden {
            display: none;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: white;
            font-size: 1.1em;
        }

        .insights {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .insight-item {
            padding: 14px;
            margin: 10px 0;
            background: #f8f9ff;
            border-left: 4px solid #667eea;
            border-radius: 5px;
            color: #374151;
            line-height: 1.4;
        }

        .analysis-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .analysis-group {
            border: 1px solid #e0e7ff;
            border-radius: 12px;
            padding: 18px;
            background: #f8f9ff;
        }

        .analysis-group h3 {
            color: #4338ca;
            margin-bottom: 6px;
        }

        .analysis-note {
            color: #4b5563;
            font-size: 0.9em;
        }

        .analysis-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        .analysis-table th,
        .analysis-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb;
            text-align: left;
        }

        .analysis-table th {
            background: #eef2ff;
            color: #4338ca;
            font-weight: 600;
        }

        .analysis-category-section {
            margin-top: 16px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 15px;
        }

        .category-block {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            padding: 14px;
            box-shadow: 0 5px 10px rgba(0,0,0,0.04);
        }

        .category-block h4 {
            font-size: 1em;
            color: #111827;
            margin-bottom: 4px;
        }

        .category-meta {
            font-size: 0.85em;
            color: #6b7280;
            margin-bottom: 8px;
        }

        .category-pill {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-radius: 8px;
            background: #eef2ff;
            margin-bottom: 6px;
            font-size: 0.9em;
            color: #1f2937;
        }

        .category-pill strong {
            color: #4338ca;
        }

        .category-pill span {
            color: #4b5563;
            font-size: 0.85em;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DLPerf Analysis Dashboard</h1>
            <p class="subtitle">Per-GPU-model conditioning (A100/H100/H200/B200 only) with non-GPU feature attribution and SiliconMark integration.</p>
        </header>

        <div id="loading" class="loading">
            Loading datacenter offers and recomputing per-model correlations...
        </div>

        <div id="content" style="display: none;">
            <section class="controls-panel">
                <div>
                    <label for="gpu-model-select">GPU Model</label>
                    <select id="gpu-model-select" class="gpu-select"></select>
                </div>
                <div>
                    <label for="num-gpus-select">Number of GPUs</label>
                    <select id="num-gpus-select" class="gpu-select"></select>
                </div>
                <p class="control-note">
                    We condition on both the exact GPU SKU (PCIe vs SXM vs NVL treated separately) <em>and</em> the number of GPUs, then look for factors that vary within that specific configuration only.
                </p>
            </section>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Instances Analyzed</div>
                    <div class="stat-value" id="model-instance-count">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Avg DLPerf</div>
                    <div class="stat-value" id="model-avg-dlperf">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Median DLPerf</div>
                    <div class="stat-value" id="model-median-dlperf">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">DLPerf Std Dev</div>
                    <div class="stat-value" id="model-std-dlperf">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Median Price / hr</div>
                    <div class="stat-value" id="model-price-median">-</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Quickmark Coverage</div>
                    <div class="stat-value" id="model-quickmark-coverage">-</div>
                </div>
            </div>

            <div class="chart-container">
                <h2 class="chart-title">Top Non-GPU Drivers (selected configuration)</h2>
                <p class="chart-subtitle">Only the requested core metrics (price per hour, CPU RAM, CPU cores/effective cores, CPU clock, and GPU max power) are considered here; each metric drops null, zero, and invalid values before correlation.</p>
                <table class="correlation-table">
                    <thead>
                        <tr>
                            <th>Factor</th>
                            <th>Correlation vs DLPerf</th>
                            <th>Direction</th>
                            <th>Samples</th>
                        </tr>
                    </thead>
                    <tbody id="model-correlation-table"></tbody>
                </table>
            </div>

            <div class="grid-2">
                <div class="chart-container">
                    <h2 class="chart-title">Price per Hour vs DLPerf (within configuration)</h2>
                    <p class="chart-subtitle">Confirms whether price dispersion within the same GPU model and GPU count reflects measured DLPerf.</p>
                    <div class="chart-wrapper">
                        <canvas id="model-price-chart"></canvas>
                    </div>
                </div>
                <div class="chart-container">
                    <h2 class="chart-title">SiliconMark Quickmark vs DLPerf</h2>
                    <p class="chart-subtitle">Benchmark the exact machines you care about (run SiliconMark quickmark and append to quickmark_results.json).</p>
                    <div id="quickmark-placeholder" class="placeholder hidden">
                        No quickmark runs captured yet. Spin up the target host, run <code>quickmark quickmark</code>, store the score in <code>quickmark_results.json</code>, and shut the instance down when done.
                    </div>
                    <div class="chart-wrapper" id="quickmark-chart-wrapper">
                        <canvas id="quickmark-chart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h2 class="chart-title">DLPerf Distribution (datacenter GPUs)</h2>
                <div class="chart-wrapper">
                    <canvas id="dlperf-distribution"></canvas>
                </div>
            </div>

            <div class="grid-2">
                <div class="chart-container">
                    <h2 class="chart-title">GPU Configuration Leaderboard</h2>
                    <p class="chart-subtitle">Average DLPerf vs median price/hr across datacenter GPU model × GPU count configurations.</p>
                    <div class="chart-wrapper tall">
                        <canvas id="gpu-model-chart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h2 class="chart-title">Cross-Configuration Non-GPU Factors</h2>
                <p class="chart-subtitle">Average absolute correlation for the requested fields (price, CPU RAM/cores/clock, GPU max power) across all GPU model × GPU count configurations.</p>
                <table class="correlation-table">
                    <thead>
                        <tr>
                            <th>Factor</th>
                            <th>Avg |corr|</th>
                            <th>Typical Direction</th>
                            <th>Strongest Configuration</th>
                            <th>Configurations Covered</th>
                        </tr>
                    </thead>
                    <tbody id="cross-model-table"></tbody>
                </table>
            </div>

            <div class="chart-container">
                <h2 class="chart-title">Core Metric Analysis (selected config)</h2>
                <p class="chart-subtitle">
                    Only CPU RAM, effective CPU cores, price per hour, CPU clock, CPU cores, and GPU max power are summarized here, conditioned on the chosen GPU model and number of GPUs. Each metric filters out null, zero, and invalid values independently before computing stats or correlations versus DLPerf.
                </p>
                <div id="global-analysis-sections" class="analysis-section"></div>
            </div>

            <div class="chart-container">
                <h2 class="chart-title">Quickmark Coverage</h2>
                <p class="chart-subtitle">Track how many benchmark runs exist per GPU configuration so we know where more sampling is needed.</p>
                <table class="correlation-table">
                    <thead>
                        <tr>
                            <th>GPU Configuration</th>
                            <th>Quickmark Runs</th>
                            <th>Coverage</th>
                            <th>Avg Quickmark Score</th>
                        </tr>
                    </thead>
                    <tbody id="quickmark-coverage-table"></tbody>
                </table>
            </div>

            <div class="insights">
                <h2 class="chart-title">Key Insights</h2>
                <div id="insights-content"></div>
            </div>
        </div>
    </div>

    <script>
        const DATACENTER_KEYWORDS = ['A100', 'H100', 'H200', 'B200'];
        const MIN_POINTS_FOR_CORRELATION = 4;
        const NON_GPU_SPECS = [
            { key: 'dph_total', label: 'Price per Hour ($)', description: 'Total hourly list price for the node', getValue: d => d.dph_total },
            { key: 'cpu_ram_gb', label: 'CPU RAM (GB)', description: 'System RAM in GB (converted)', getValue: d => d.cpu_ram_gb },
            { key: 'cpu_cores_effective', label: 'Effective CPU Cores', description: 'CPU threads available to the VM', getValue: d => d.cpu_cores_effective },
            { key: 'cpu_ghz', label: 'CPU Clock (GHz)', description: 'Host CPU frequency', getValue: d => d.cpu_ghz },
            { key: 'cpu_cores', label: 'CPU Cores', description: 'Reported physical cores', getValue: d => d.cpu_cores },
            { key: 'gpu_max_power', label: 'GPU Max Power (W)', description: 'Advertised card power budget', getValue: d => d.gpu_max_power }
        ];

        const GLOBAL_ANALYSIS_GROUPS = [
            {
                id: 'core-metrics',
                title: 'Core Capacity (per GPU model × GPU count)',
                description: 'Only the requested fields are summarized here. Each metric filters out null, zero, and invalid entries before computing stats or correlations within the selected configuration.',
                metrics: [
                    { key: 'dph_total', label: 'Price per Hour', type: 'numeric', unit: '$/hr', decimals: 4, description: 'Total hourly list price for the node', getValue: d => d.dph_total },
                    { key: 'cpu_ram_gb', label: 'CPU RAM (GB)', type: 'numeric', unit: 'GB', decimals: 1, description: 'System memory assigned to the VM', getValue: d => d.cpu_ram_gb },
                    { key: 'cpu_cores_effective', label: 'Effective CPU Cores', type: 'numeric', decimals: 0, description: 'vCPU/threads actually exposed to the guest', getValue: d => d.cpu_cores_effective },
                    { key: 'cpu_ghz', label: 'CPU Clock (GHz)', type: 'numeric', decimals: 2, description: 'Host CPU frequency', getValue: d => d.cpu_ghz },
                    { key: 'cpu_cores', label: 'CPU Cores', type: 'numeric', decimals: 0, description: 'Reported physical cores', getValue: d => d.cpu_cores },
                    { key: 'gpu_max_power', label: 'GPU Max Power (W)', type: 'numeric', unit: 'W', decimals: 0, description: 'Advertised card power budget', getValue: d => d.gpu_max_power }
                ]
            }
        ];

        let datacenterData = [];
        let groupedByModel = {};
        let groupedByModelAndGpus = {};
        let perModelSummaries = {};
        let aggregatedFactors = [];
        let selectedModel = null;
        let selectedNumGpus = null;
        const charts = {};

        Promise.all([
            fetch('offers.json').then(res => res.json()),
            fetch('quickmark_results.json').then(res => res.ok ? res.json() : []).catch(() => [])
        ])
            .then(([offers, quickmarks]) => {
                initializeDashboard(offers, quickmarks || []);
            })
            .catch(error => {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 'Error loading data. Ensure offers.json and quickmark_results.json exist.';
            });

        function initializeDashboard(offers, quickmarks) {
            const quickmarkMap = buildQuickmarkMap(quickmarks);
            datacenterData = offers
                .filter(isDatacenterGpu)
                .filter(item => item.dlperf != null && item.dlperf > 0)
                .map(item => normalizeRecord(item, quickmarkMap));

            if (!datacenterData.length) {
                document.getElementById('loading').innerHTML = 'No datacenter-class GPU offers found (A100/H100/H200/B200).';
                return;
            }

            groupedByModel = groupBy(datacenterData, item => item.gpu_name);
            groupedByModelAndGpus = groupBy(datacenterData, item => `${item.gpu_name}|${item.num_gpus || 'unknown'}`);
            perModelSummaries = buildPerModelSummaries(groupedByModelAndGpus);
            aggregatedFactors = buildAggregatedFactors(perModelSummaries);

            populateModelSelect(Object.keys(groupedByModel));
            renderCrossModelTable(aggregatedFactors);
            renderQuickmarkCoverageTable(perModelSummaries);
            createDistributionChart();
            createGpuLeaderboardChart();

            document.getElementById('loading').style.display = 'none';
            document.getElementById('content').style.display = 'block';

            const modelSelect = document.getElementById('gpu-model-select');
            selectedModel = modelSelect.value;
            updateNumGpusSelect();
            const numGpusSelect = document.getElementById('num-gpus-select');
            selectedNumGpus = numGpusSelect.value;
            updateModelView();
        }

        function isDatacenterGpu(item) {
            const name = (item.gpu_name || '').toUpperCase();
            return DATACENTER_KEYWORDS.some(keyword => name.includes(keyword));
        }

        function normalizeRecord(item, quickmarkMap) {
            const quickmark = quickmarkMap.get(`machine-${item.machine_id}`) || quickmarkMap.get(`host-${item.host_id}`) || null;
            return {
                ...item,
                gpu_name: (item.gpu_name || 'Unknown GPU').trim(),
                cpu_ram_gb: item.cpu_ram != null ? item.cpu_ram / 1024 : null,
                listing_uptime_hours: item.duration != null ? item.duration / 3600 : null,
                quickmark_entry: quickmark
            };
        }

        function buildQuickmarkMap(entries) {
            const map = new Map();
            (entries || []).forEach(entry => {
                if (!entry) return;
                const normalized = normalizeQuickmarkEntry(entry);
                if (entry.machine_id != null) {
                    map.set(`machine-${entry.machine_id}`, normalized);
                }
                if (entry.host_id != null) {
                    map.set(`host-${entry.host_id}`, normalized);
                }
            });
            return map;
        }

        function normalizeQuickmarkEntry(entry) {
            return {
                ...entry,
                quickmark_score: entry.quickmark_score != null ? Number(entry.quickmark_score) : null,
                measured_at: entry.measured_at || null
            };
        }

        function groupBy(array, fn) {
            return array.reduce((acc, item) => {
                const key = fn(item);
                if (!acc[key]) acc[key] = [];
                acc[key].push(item);
                return acc;
            }, {});
        }

        function buildPerModelSummaries(groups) {
            const summaries = {};
            Object.entries(groups).forEach(([model, dataset]) => {
                const dlperfValues = dataset.map(item => item.dlperf);
                const priceValues = dataset.map(item => item.dph_total).filter(isFinite);
                const quickmarkEntries = dataset
                    .map(item => {
                        const quickmark = item.quickmark_entry;
                        if (!quickmark || quickmark.quickmark_score == null || isNaN(quickmark.quickmark_score)) return null;
                        return {
                            score: Number(quickmark.quickmark_score),
                            dlperf: item.dlperf,
                            machine_id: item.machine_id,
                            host_id: item.host_id,
                            measured_at: quickmark.measured_at,
                            notes: quickmark.notes || ''
                        };
                    })
                    .filter(Boolean);

                summaries[model] = {
                    dataset,
                    count: dataset.length,
                    dlperfStats: computeStats(dlperfValues),
                    priceStats: computeStats(priceValues, { skipZero: true }),
                    correlations: computeCorrelations(dataset, NON_GPU_SPECS),
                    quickmarkEntries,
                    quickmarkStats: computeStats(quickmarkEntries.map(entry => entry.score))
                };
            });
            return summaries;
        }

        function computeStats(values, options = {}) {
            const { skipZero = false } = options;
            const filtered = [];
            (values || []).forEach(raw => {
                if (raw == null) return;
                const parsed = typeof raw === 'string' ? Number(raw.trim()) : raw;
                if (!Number.isFinite(parsed)) return;
                if (skipZero && parsed === 0) return;
                filtered.push(parsed);
            });
            if (!filtered.length) {
                return { avg: null, median: null, min: null, max: null, std: null, count: 0 };
            }
            const sorted = [...filtered].sort((a, b) => a - b);
            const sum = filtered.reduce((a, b) => a + b, 0);
            const avg = sum / filtered.length;
            const variance = filtered.length === 1 ? 0 : filtered.reduce((acc, value) => acc + Math.pow(value - avg, 2), 0) / filtered.length;
            return {
                avg,
                median: median(sorted),
                min: sorted[0],
                max: sorted[sorted.length - 1],
                std: Math.sqrt(variance),
                count: filtered.length
            };
        }

        function median(sortedValues) {
            if (!sortedValues.length) return null;
            const mid = Math.floor(sortedValues.length / 2);
            if (sortedValues.length % 2 === 0) {
                return (sortedValues[mid - 1] + sortedValues[mid]) / 2;
            }
            return sortedValues[mid];
        }

        function computeCorrelations(dataset, specs) {
            const correlations = [];
            specs.forEach(spec => {
                const pairs = dataset.reduce((acc, item) => {
                    const rawX = spec.getValue(item);
                    const rawY = item.dlperf;
                    if (rawX == null || rawY == null) return acc;
                    const x = typeof rawX === 'string' ? Number(String(rawX).trim()) : rawX;
                    const y = typeof rawY === 'string' ? Number(String(rawY).trim()) : rawY;
                    if (!Number.isFinite(x) || !Number.isFinite(y)) return acc;
                    if (x === 0) return acc;
                    acc.push({ x, y });
                    return acc;
                }, []);

                if (pairs.length >= MIN_POINTS_FOR_CORRELATION) {
                    const xValues = pairs.map(pair => pair.x);
                    const yValues = pairs.map(pair => pair.y);
                    const corr = calculateCorrelation(xValues, yValues);
                    correlations.push({
                        key: spec.key,
                        label: spec.label,
                        description: spec.description,
                        correlation: corr,
                        count: pairs.length
                    });
                }
            });

            return correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
        }

        function calculateCorrelation(x, y) {
            const n = x.length;
            if (!n) return 0;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
            const sumY2 = y.reduce((sum, yi) => sum + yi * yi, 0);
            const numerator = n * sumXY - sumX * sumY;
            const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
            if (denominator === 0) return 0;
            return numerator / denominator;
        }

        function getCorrelationStrength(value) {
            const abs = Math.abs(value);
            if (abs >= 0.7) return { label: 'Strong', class: 'correlation-high' };
            if (abs >= 0.4) return { label: 'Medium', class: 'correlation-medium' };
            return { label: 'Weak', class: 'correlation-low' };
        }

        function populateModelSelect(models) {
            const select = document.getElementById('gpu-model-select');
            select.innerHTML = '';
            const sortedModels = models
                .map(name => ({ name, count: groupedByModel[name]?.length || 0 }))
                .sort((a, b) => b.count - a.count);

            sortedModels.forEach(entry => {
                const option = document.createElement('option');
                option.value = entry.name;
                option.textContent = `${entry.name} (${entry.count})`;
                select.appendChild(option);
            });

            if (!select.dataset.bound) {
                select.addEventListener('change', event => {
                    selectedModel = event.target.value;
                    updateNumGpusSelect();
                    const numGpusSelect = document.getElementById('num-gpus-select');
                    selectedNumGpus = numGpusSelect.value;
                    updateModelView();
                });
                select.dataset.bound = 'true';
            }
        }

        function updateNumGpusSelect() {
            const select = document.getElementById('num-gpus-select');
            select.innerHTML = '';
            
            if (!selectedModel) {
                return;
            }

            const modelData = groupedByModel[selectedModel] || [];
            const numGpusCounts = {};
            modelData.forEach(item => {
                const numGpus = item.num_gpus || 'unknown';
                numGpusCounts[numGpus] = (numGpusCounts[numGpus] || 0) + 1;
            });

            const sortedNumGpus = Object.entries(numGpusCounts)
                .map(([numGpus, count]) => ({ numGpus, count }))
                .sort((a, b) => {
                    const aNum = a.numGpus === 'unknown' ? -1 : Number(a.numGpus);
                    const bNum = b.numGpus === 'unknown' ? -1 : Number(b.numGpus);
                    return aNum - bNum;
                });

            sortedNumGpus.forEach(entry => {
                const option = document.createElement('option');
                option.value = entry.numGpus;
                option.textContent = `${entry.numGpus === 'unknown' ? 'Unknown' : entry.numGpus} GPU${entry.numGpus === 1 ? '' : 's'} (${entry.count})`;
                select.appendChild(option);
            });

            if (!select.dataset.bound) {
                select.addEventListener('change', event => {
                    selectedNumGpus = event.target.value;
                    updateModelView();
                });
                select.dataset.bound = 'true';
            }
        }

        function updateModelView() {
            if (!selectedModel || selectedNumGpus === null) return;
            const compositeKey = `${selectedModel}|${selectedNumGpus}`;
            const summary = perModelSummaries[compositeKey];
            if (!summary) return;
            updateStatsCards(summary);
            renderModelCorrelationTable(summary.correlations);
            renderPriceChart(summary.dataset);
            renderQuickmarkChart(summary.quickmarkEntries);
            renderGlobalAnalysis(buildGlobalAnalysis(summary.dataset));
            updateInsights(summary);
        }

        function updateStatsCards(summary) {
            document.getElementById('model-instance-count').textContent = summary.count.toLocaleString();
            document.getElementById('model-avg-dlperf').textContent = formatNumber(summary.dlperfStats.avg);
            document.getElementById('model-median-dlperf').textContent = formatNumber(summary.dlperfStats.median);
            document.getElementById('model-std-dlperf').textContent = formatNumber(summary.dlperfStats.std);
            document.getElementById('model-price-median').textContent = formatCurrency(summary.priceStats.median);

            const quickmarkRuns = summary.quickmarkEntries.length;
            const coveragePct = summary.count ? ((quickmarkRuns / summary.count) * 100).toFixed(0) : 0;
            document.getElementById('model-quickmark-coverage').textContent = quickmarkRuns
                ? `${quickmarkRuns}/${summary.count} (${coveragePct}%)`
                : '0 recorded';
        }

        function renderModelCorrelationTable(correlations) {
            const tbody = document.getElementById('model-correlation-table');
            tbody.innerHTML = '';

            if (!correlations.length) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="4">Not enough variation in non-GPU specs for this model yet.</td>';
                tbody.appendChild(row);
                return;
            }

            correlations.slice(0, 8).forEach(item => {
                const strength = getCorrelationStrength(item.correlation);
                const direction = item.correlation > 0 ? 'Higher value → higher DLPerf' : 'Higher value → lower DLPerf';
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>
                        <strong>${item.label}</strong>
                        <div style="color:#6b7280;font-size:0.85em;">${item.description}</div>
                    </td>
                    <td><span class="correlation-value ${strength.class}">${item.correlation > 0 ? '+' : ''}${item.correlation.toFixed(3)}</span> ${strength.label}</td>
                    <td>${direction}</td>
                    <td>${item.count}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function renderPriceChart(dataset) {
            const canvasId = 'model-price-chart';
            const ctx = document.getElementById(canvasId).getContext('2d');
            const pairs = dataset.reduce((acc, item) => {
                const rawPrice = item.dph_total;
                const rawDlperf = item.dlperf;
                if (rawPrice == null || rawDlperf == null) return acc;
                const price = typeof rawPrice === 'string' ? Number(rawPrice.trim()) : rawPrice;
                const dlperf = typeof rawDlperf === 'string' ? Number(String(rawDlperf).trim()) : rawDlperf;
                if (!Number.isFinite(price) || !Number.isFinite(dlperf)) return acc;
                if (price === 0) return acc;
                acc.push({ x: price, y: dlperf });
                return acc;
            }, []);

            const correlation = pairs.length ? calculateCorrelation(pairs.map(p => p.x), pairs.map(p => p.y)) : 0;

            if (charts[canvasId]) charts[canvasId].destroy();

            charts[canvasId] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `Corr: ${safeToFixed(correlation, 3)}`,
                        data: pairs,
                        backgroundColor: 'rgba(99, 102, 241, 0.6)',
                        borderColor: 'rgba(99, 102, 241, 1)',
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Price per Hour (USD)' }
                        },
                        y: {
                            title: { display: true, text: 'DLPerf' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: context => `Price: $${context.parsed.x.toFixed(4)}, DLPerf: ${context.parsed.y.toFixed(1)}`
                            }
                        }
                    }
                }
            });
        }

        function renderQuickmarkChart(entries) {
            const placeholder = document.getElementById('quickmark-placeholder');
            const wrapper = document.getElementById('quickmark-chart-wrapper');
            const canvasId = 'quickmark-chart';
            const canvas = document.getElementById(canvasId);

            if (!entries.length) {
                placeholder.classList.remove('hidden');
                wrapper.style.display = 'none';
                if (charts[canvasId]) {
                    charts[canvasId].destroy();
                    delete charts[canvasId];
                }
                return;
            }

            placeholder.classList.add('hidden');
            wrapper.style.display = 'block';

            const pairs = entries.map(entry => ({
                x: entry.score,
                y: entry.dlperf,
                machine: entry.machine_id,
                host: entry.host_id,
                measured_at: entry.measured_at
            }));

            const correlation = calculateCorrelation(pairs.map(p => p.x), pairs.map(p => p.y));

            if (charts[canvasId]) charts[canvasId].destroy();

            charts[canvasId] = new Chart(canvas.getContext('2d'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: `Corr: ${safeToFixed(correlation, 3)}`,
                        data: pairs,
                        backgroundColor: 'rgba(16, 185, 129, 0.7)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'SiliconMark Quickmark Score' }
                        },
                        y: {
                            title: { display: true, text: 'DLPerf' }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: context => {
                                    const data = context.raw;
                                    return `Quickmark: ${data.x.toFixed(1)}, DLPerf: ${data.y.toFixed(1)}, machine ${data.machine}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createDistributionChart() {
            const canvasId = 'dlperf-distribution';
            const ctx = document.getElementById(canvasId).getContext('2d');
            const values = datacenterData.map(item => item.dlperf);
            if (!values.length) return;

            const min = Math.min(...values);
            const max = Math.max(...values);
            const range = max - min;
            let binSize = 100;
            if (range > 4000) binSize = 400;
            else if (range > 2000) binSize = 200;
            else if (range > 1000) binSize = 100;
            else if (range > 500) binSize = 50;

            const minRounded = Math.floor(min / binSize) * binSize;
            const maxRounded = Math.ceil(max / binSize) * binSize;
            const binCount = Math.max(1, Math.ceil((maxRounded - minRounded) / binSize));
            const bins = Array(binCount).fill(0);
            const labels = [];

            for (let i = 0; i < binCount; i++) {
                const start = minRounded + i * binSize;
                const end = start + binSize;
                labels.push(`${start}-${end}`);
            }

            values.forEach(value => {
                const idx = Math.min(Math.floor((value - minRounded) / binSize), binCount - 1);
                if (idx >= 0 && idx < binCount) bins[idx]++;
            });

            if (charts[canvasId]) charts[canvasId].destroy();

            charts[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Instances',
                        data: bins,
                        backgroundColor: 'rgba(99, 102, 241, 0.7)',
                        borderColor: 'rgba(99, 102, 241, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { title: { display: true, text: 'DLPerf range' } },
                        y: { title: { display: true, text: 'Instances' }, beginAtZero: true }
                    }
                }
            });
        }

        function createGpuLeaderboardChart() {
            const canvasId = 'gpu-model-chart';
            const ctx = document.getElementById(canvasId).getContext('2d');
            const rows = Object.entries(perModelSummaries)
                .map(([key, summary]) => {
                    const [model, numGpus] = key.split('|');
                    return {
                        label: `${model} × ${numGpus === 'unknown' ? '?' : numGpus} GPU${numGpus === 1 ? '' : 's'}`,
                        avgDlperf: summary.dlperfStats.avg || 0,
                        medianPrice: summary.priceStats.median || 0,
                        count: summary.count
                    };
                })
                .sort((a, b) => b.avgDlperf - a.avgDlperf);

            if (!rows.length) return;
            if (charts[canvasId]) charts[canvasId].destroy();

            charts[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: rows.map(row => row.label),
                    datasets: [{
                        label: 'Avg DLPerf',
                        data: rows.map(row => row.avgDlperf),
                        backgroundColor: 'rgba(99, 102, 241, 0.7)',
                        borderColor: 'rgba(99, 102, 241, 1)',
                        yAxisID: 'y'
                    }, {
                        label: 'Median Price/hr',
                        data: rows.map(row => row.medianPrice),
                        type: 'line',
                        borderColor: '#f59e0b',
                        backgroundColor: '#f59e0b',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            position: 'left',
                            title: { display: true, text: 'Avg DLPerf' }
                        },
                        y1: {
                            position: 'right',
                            title: { display: true, text: 'Median price/hr (USD)' },
                            grid: { drawOnChartArea: false }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterLabel: context => `Instances: ${rows[context.dataIndex].count}`
                            }
                        }
                    },
                    interaction: { mode: 'index', intersect: false }
                }
            });
        }

        function buildAggregatedFactors(summaries) {
            const factorMap = {};
            Object.entries(summaries).forEach(([model, summary]) => {
                summary.correlations.forEach(entry => {
                    if (!factorMap[entry.key]) factorMap[entry.key] = [];
                    factorMap[entry.key].push({ model, correlation: entry.correlation, count: entry.count, label: entry.label, description: entry.description });
                });
            });

            return Object.entries(factorMap)
                .map(([key, entries]) => {
                    const avgAbs = entries.reduce((sum, entry) => sum + Math.abs(entry.correlation), 0) / entries.length;
                    const avgCorr = entries.reduce((sum, entry) => sum + entry.correlation, 0) / entries.length;
                    const strongest = entries.slice().sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation))[0];
                    return {
                        key,
                        label: strongest.label,
                        description: strongest.description,
                        avgAbsCorrelation: avgAbs,
                        avgCorrelation: avgCorr,
                        coverage: entries.length,
                        strongestModel: strongest
                    };
                })
                .sort((a, b) => b.avgAbsCorrelation - a.avgAbsCorrelation);
        }

        function renderCrossModelTable(factors) {
            const tbody = document.getElementById('cross-model-table');
            tbody.innerHTML = '';

            if (!factors.length) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="5">No cross-model factors computed yet.</td>';
                tbody.appendChild(row);
                return;
            }

            factors.slice(0, 8).forEach(factor => {
                const direction = factor.avgCorrelation > 0.05
                    ? 'Higher value → higher DLPerf'
                    : factor.avgCorrelation < -0.05
                        ? 'Higher value → lower DLPerf'
                        : 'Mixed';

                const [strongestModel, strongestNumGpus] = factor.strongestModel.model.split('|');
                const strongestLabel = `${strongestModel} × ${strongestNumGpus === 'unknown' ? '?' : strongestNumGpus} GPU${strongestNumGpus === 1 ? '' : 's'}`;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>
                        <strong>${factor.label}</strong>
                        <div style="color:#6b7280;font-size:0.85em;">${factor.description}</div>
                    </td>
                    <td>${factor.avgAbsCorrelation.toFixed(3)}</td>
                    <td>${direction}</td>
                    <td>${strongestLabel} (${factor.strongestModel.correlation > 0 ? '+' : ''}${factor.strongestModel.correlation.toFixed(3)})</td>
                    <td>${factor.coverage} configs</td>
                `;
                tbody.appendChild(row);
            });
        }

        function renderQuickmarkCoverageTable(summaries) {
            const tbody = document.getElementById('quickmark-coverage-table');
            tbody.innerHTML = '';

            const rows = Object.entries(summaries)
                .map(([key, summary]) => {
                    const [model, numGpus] = key.split('|');
                    return {
                        model,
                        numGpus,
                        label: `${model} × ${numGpus === 'unknown' ? '?' : numGpus} GPU${numGpus === 1 ? '' : 's'}`,
                        runs: summary.quickmarkEntries.length,
                        total: summary.count,
                        avgScore: summary.quickmarkStats.avg
                    };
                })
                .sort((a, b) => b.runs - a.runs);

            rows.forEach(row => {
                const coverage = row.total ? `${((row.runs / row.total) * 100).toFixed(0)}%` : '0%';
                const displayScore = row.runs ? formatNumber(row.avgScore) : '—';
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${row.label}</td>
                    <td>${row.runs}</td>
                    <td>${row.runs}/${row.total} (${coverage})</td>
                    <td>${displayScore}</td>
                `;
                tbody.appendChild(tr);
            });

            if (!rows.some(row => row.runs > 0)) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="4">No quickmark data yet. Run SiliconMark quickmark on your shortlist and append the results.</td>';
                tbody.appendChild(row);
            }
        }

        function buildGlobalAnalysis(dataset) {
            const total = dataset.length;
            return GLOBAL_ANALYSIS_GROUPS.map(group => {
                const numericResults = group.metrics
                    .filter(metric => metric.type === 'numeric')
                    .map(metric => computeNumericAnalysis(metric, dataset, total));
                const categoricalResults = group.metrics
                    .filter(metric => metric.type === 'categorical')
                    .map(metric => computeCategoricalAnalysis(metric, dataset));
                return {
                    ...group,
                    numericResults,
                    categoricalResults
                };
            });
        }

        function computeNumericAnalysis(metric, dataset, totalCount) {
            const points = [];
            dataset.forEach(item => {
                let value = metric.getValue ? metric.getValue(item) : item[metric.key];
                if (value == null) return;
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (!trimmed) return;
                    value = Number(trimmed);
                }
                if (typeof value !== 'number' || Number.isNaN(value) || !Number.isFinite(value)) return;
                const skipZero = metric.skipZero !== false;
                if (skipZero && value === 0) return;
                points.push({ value, dlperf: item.dlperf });
            });

            const stats = computeExtendedStats(points.map(point => point.value));
            const correlation = (metric.correlate === false || points.length < MIN_POINTS_FOR_CORRELATION)
                ? null
                : calculateCorrelation(points.map(point => point.value), points.map(point => point.dlperf));

            return {
                key: metric.key,
                label: metric.label,
                description: metric.description || '',
                unit: metric.unit || '',
                decimals: metric.decimals != null ? metric.decimals : 1,
                samples: points.length,
                coverage: totalCount ? points.length / totalCount : 0,
                stats,
                correlation
            };
        }

        function computeExtendedStats(values) {
            const filtered = (values || []).filter(value => value != null && !Number.isNaN(value));
            if (!filtered.length) return null;
            const sorted = filtered.slice().sort((a, b) => a - b);
            const sum = filtered.reduce((acc, value) => acc + value, 0);
            return {
                min: sorted[0],
                max: sorted[sorted.length - 1],
                median: median(sorted),
                avg: sum / filtered.length,
                p25: percentile(sorted, 0.25),
                p75: percentile(sorted, 0.75)
            };
        }

        function percentile(sortedValues, percentileFraction) {
            if (!sortedValues.length) return null;
            const index = (sortedValues.length - 1) * percentileFraction;
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            if (lower === upper) return sortedValues[lower];
            const weight = index - lower;
            return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;
        }

        function computeCategoricalAnalysis(metric, dataset) {
            const counts = new Map();
            dataset.forEach(item => {
                const raw = metric.getValue ? metric.getValue(item) : item[metric.key];
                const normalized = normalizeCategoricalValue(raw);
                if (normalized === null) return;
                const key = typeof normalized === 'object' ? JSON.stringify(normalized) : String(normalized);
                if (!counts.has(key)) {
                    const display = metric.formatCategory
                        ? metric.formatCategory(normalized)
                        : String(normalized);
                    counts.set(key, { label: display, count: 0, dlperfs: [] });
                }
                const entry = counts.get(key);
                entry.count += 1;
                if (item.dlperf != null && !Number.isNaN(item.dlperf)) {
                    entry.dlperfs.push(item.dlperf);
                }
            });

            const totalSamples = Array.from(counts.values()).reduce((sum, entry) => sum + entry.count, 0);
            const topValues = Array.from(counts.values())
                .map(entry => ({
                    label: entry.label,
                    count: entry.count,
                    share: totalSamples ? entry.count / totalSamples : 0,
                    avgDlperf: entry.dlperfs.length
                        ? entry.dlperfs.reduce((acc, value) => acc + value, 0) / entry.dlperfs.length
                        : null
                }))
                .sort((a, b) => b.count - a.count)
                .slice(0, metric.topN || 5);

            return {
                key: metric.key,
                label: metric.label,
                description: metric.description || '',
                samples: totalSamples,
                uniqueCount: counts.size,
                topValues
            };
        }

        function normalizeCategoricalValue(value) {
            if (value == null) return null;
            if (typeof value === 'string') {
                const trimmed = value.trim();
                return trimmed || 'Unknown';
            }
            if (typeof value === 'boolean' || typeof value === 'number') {
                return value;
            }
            return String(value);
        }

        function renderGlobalAnalysis(groups) {
            const container = document.getElementById('global-analysis-sections');
            if (!container) return;
            container.innerHTML = '';

            if (!groups.length) {
                container.innerHTML = '<div class="analysis-note">Analysis not available. Load offers.json first.</div>';
                return;
            }

            groups.forEach(group => {
                const section = document.createElement('div');
                section.className = 'analysis-group';
                section.innerHTML = `
                    <h3>${group.title}</h3>
                    <p class="analysis-note">${group.description}</p>
                `;

                if (group.numericResults.length) {
                    const table = document.createElement('table');
                    table.className = 'analysis-table';
                    const rows = group.numericResults.map(result => {
                        const stats = result.stats;
                        const coverageText = result.samples
                            ? `${result.samples.toLocaleString()} (${(result.coverage * 100).toFixed(0)}%)`
                            : '0';
                        const medianText = stats ? appendUnit(formatNumber(stats.median, result.decimals), result.unit) : '—';
                        const meanText = stats ? appendUnit(formatNumber(stats.avg, result.decimals), result.unit) : '—';
                        const rangeText = stats
                            ? `${appendUnit(formatNumber(stats.min, result.decimals), result.unit)} → ${appendUnit(formatNumber(stats.max, result.decimals), result.unit)}`
                            : '—';
                        const corrText = renderCorrelationPill(result.correlation);
                        return `
                            <tr>
                                <td>
                                    <strong>${result.label}</strong>
                                    <div style="color:#6b7280;font-size:0.85em;">${result.description}</div>
                                </td>
                                <td>${coverageText}</td>
                                <td>${medianText}</td>
                                <td>${meanText}</td>
                                <td>${rangeText}</td>
                                <td>${corrText}</td>
                            </tr>
                        `;
                    }).join('');
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Valid samples</th>
                                <th>Median</th>
                                <th>Mean</th>
                                <th>Min → Max</th>
                                <th>Correlation</th>
                            </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                    `;
                    section.appendChild(table);
                }

                if (group.categoricalResults.length) {
                    const categorySection = document.createElement('div');
                    categorySection.className = 'analysis-category-section';
                    group.categoricalResults.forEach(result => {
                        const block = document.createElement('div');
                        block.className = 'category-block';
                        const meta = result.samples
                            ? `${result.samples.toLocaleString()} samples · ${result.uniqueCount} unique`
                            : 'No populated data yet';
                        const items = result.topValues.length
                            ? result.topValues.map(entry => {
                                const percent = `${(entry.share * 100).toFixed(1)}%`;
                                return `
                                    <div class="category-pill">
                                        <div>
                                            <strong>${entry.label}</strong>
                                            <span>${entry.count.toLocaleString()} (${percent})</span>
                                        </div>
                                        <span>Avg DLPerf ${formatNumber(entry.avgDlperf)}</span>
                                    </div>
                                `;
                            }).join('')
                            : '<div class="category-pill"><div>No populated values.</div></div>';

                        block.innerHTML = `
                            <h4>${result.label}</h4>
                            <div class="category-meta">${result.description} · ${meta}</div>
                            ${items}
                        `;
                        categorySection.appendChild(block);
                    });
                    section.appendChild(categorySection);
                }

                container.appendChild(section);
            });
        }

        function appendUnit(value, unit) {
            if (value === '—' || !unit) return value;
            return `${value} ${unit}`;
        }

        function renderCorrelationPill(value) {
            if (value == null) return '—';
            const strength = getCorrelationStrength(value);
            return `<span class="correlation-value ${strength.class}">${value > 0 ? '+' : ''}${value.toFixed(3)}</span>`;
        }

        function updateInsights(summary) {
            const container = document.getElementById('insights-content');
            const insights = [];

            const dlperfStats = summary.dlperfStats;
            const configLabel = `${selectedModel} × ${selectedNumGpus === 'unknown' ? '?' : selectedNumGpus} GPU${selectedNumGpus === 1 ? '' : 's'}`;
            insights.push(`
                <div class="insight-item">
                    <strong>${configLabel}</strong> spans DLPerf ${formatNumber(dlperfStats.min)} to ${formatNumber(dlperfStats.max)} (std dev ${formatNumber(dlperfStats.std)}).
                    All findings below compare only machines that keep both the GPU model and number of GPUs constant.
                </div>
            `);

            const topFactors = summary.correlations.slice(0, 3);
            if (topFactors.length) {
                const factorText = topFactors
                    .map(f => `${f.label} (${f.correlation > 0 ? '+' : ''}${f.correlation.toFixed(2)})`)
                    .join(', ');
                insights.push(`
                    <div class="insight-item">
                        <strong>Non-GPU knobs moving DLPerf:</strong> ${factorText}.
                        These knobs are independent of the GPU silicon yet still shift DLPerf materially.
                    </div>
                `);
            }

            const priceCorr = summary.correlations.find(f => f.key === 'dph_total');
            if (priceCorr) {
                const direction = priceCorr.correlation < 0 ? 'cheaper nodes deliver higher DLPerf' : 'higher prices track higher DLPerf';
                insights.push(`
                    <div class="insight-item">
                        <strong>Price discipline (${configLabel}):</strong> correlation ${priceCorr.correlation.toFixed(2)} → ${direction}.
                        We only compare listings that share the same GPU model and GPU count.
                    </div>
                `);
            }

            if (aggregatedFactors.length) {
                const crossHighlights = aggregatedFactors.slice(0, 3)
                    .map(f => `${f.label} (${f.avgAbsCorrelation.toFixed(2)} avg |corr|)`).join(', ');
                insights.push(`
                    <div class="insight-item">
                        <strong>Cross-configuration agreement:</strong> ${crossHighlights} consistently explain DLPerf swings across datacenter GPU configurations without touching VRAM, TFLOPS, GPU count, or other baked-in specs.
                    </div>
                `);
            }

            if (summary.quickmarkEntries.length) {
                const quickmarkCorr = calculateCorrelation(summary.quickmarkEntries.map(e => e.score), summary.quickmarkEntries.map(e => e.dlperf));
                insights.push(`
                    <div class="insight-item">
                        <strong>Quickmark coverage:</strong> ${summary.quickmarkEntries.length} benchmarked machines with quickmark⇄DLPerf correlation ${quickmarkCorr.toFixed(2)}.
                        Use these runs to validate DLPerf anomalies before scaling up.
                    </div>
                `);
            } else {
                insights.push(`
                    <div class="insight-item">
                        <strong>Action:</strong> run SiliconMark quickmark on representative ${configLabel} hosts (rent → benchmark → terminate) and drop the JSON into <code>quickmark_results.json</code> so the scatter plot/coverage fill in.
                    </div>
                `);
            }

            container.innerHTML = insights.join('');
        }

        function formatNumber(value, decimals = 1) {
            if (value == null || isNaN(value)) return '—';
            return Number(value).toFixed(decimals);
        }

        function formatCurrency(value) {
            if (value == null || isNaN(value)) return '—';
            return `$${Number(value).toFixed(4)}`;
        }

        function safeToFixed(value, decimals) {
            if (value == null || isNaN(value)) return '0.000';
            return value.toFixed(decimals);
        }
    </script>
</body>
</html>
